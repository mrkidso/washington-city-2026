<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Washington City 2026 – Annexation & New City Boundaries</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- MapLibre GL -->
  <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    .controls {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 10;
      background: rgba(255,255,255,0.92);
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.15);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-size: 14px;
      line-height: 1.2;
      max-width: 330px;
      user-select: none;
    }

    .controls .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin: 6px 0;
    }

    .controls .title {
      font-weight: 700;
      margin-bottom: 6px;
      font-size: 14px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #f2f2f2;
      cursor: pointer;
    }

    input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .legend {
      margin-top: 8px;
      border-top: 1px solid rgba(0,0,0,0.08);
      padding-top: 8px;
      color: #333;
    }

    .swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      display: inline-block;
      vertical-align: middle;
      margin-right: 8px;
      border: 1px solid rgba(0,0,0,0.2);
    }

    .muted { color: #666; font-size: 12px; margin-top: 6px; }

    /* Make popups a bit cleaner */
    .maplibregl-popup-content {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-size: 14px;
      line-height: 1.25;
      border-radius: 10px;
    }
    .popup-title {
      font-weight: 800;
      margin-bottom: 4px;
    }
    .popup-field {
      margin-top: 2px;
      color: #222;
    }
    .popup-muted {
      color: #666;
      font-style: italic;
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="controls">
    <div class="title">Layers</div>

    <div class="row">
      <label class="pill" for="toggleAnnex" title="Toggle the annex polygon on/off">
        <input id="toggleAnnex" type="checkbox" checked />
        <span>Show <strong>new annex.geojson</strong></span>
      </label>
    </div>

    <div class="legend">
      <div class="row" style="justify-content:flex-start;">
        <span class="swatch" style="background: rgba(0, 140, 255, 0.50);"></span>
        <span>Annex (50% transparent fill)</span>
      </div>
      <div class="row" style="justify-content:flex-start;">
        <span class="swatch" style="background: transparent; border: 2px solid red;"></span>
        <span>New City Boundaries (red outline)</span>
      </div>
      <div class="muted">
        Click a feature to see a popup.<br/>
        Annex shows field <code>Des</code>. Boundaries show field <code>name</code>.
      </div>
    </div>
  </div>

  <script>
    // ====== FILES (must match your repo filenames exactly) ======
    const ANNEX_URL = "./new annex.geojson";
    const BOUNDARIES_URL = "./new city boundaries.geojson";

    // ====== IDs ======
    const SRC_ANNEX = "src-annex";
    const SRC_BOUND = "src-boundaries";

    const LYR_ANNEX_FILL = "annex-fill";
    const LYR_ANNEX_OUTLINE = "annex-outline";
    const LYR_BOUND_LINE = "boundaries-line";

    // ====== BASEMAP (Satellite + state/city reference) ======
    const style = {
      version: 8,
      sources: {
        "esri-imagery": {
          type: "raster",
          tiles: [
            "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
          ],
          tileSize: 256,
          attribution:
            'Tiles &copy; Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
        },
        "esri-reference": {
          type: "raster",
          tiles: [
            "https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}"
          ],
          tileSize: 256
        }
      },
      layers: [
        { id: "imagery", type: "raster", source: "esri-imagery" },
        { id: "reference", type: "raster", source: "esri-reference" }
      ]
    };

    const map = new maplibregl.Map({
      container: "map",
      style,
      center: [-113.51, 37.13],
      zoom: 11,
      hash: true
    });

    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), "top-right");

    // ====== HELPERS ======
    function toFeatureCollection(geojson) {
      if (!geojson) throw new Error("Empty GeoJSON");
      if (geojson.type === "FeatureCollection") return geojson;
      if (geojson.type === "Feature") return { type: "FeatureCollection", features: [geojson] };
      if (geojson.type && geojson.coordinates) {
        return {
          type: "FeatureCollection",
          features: [{ type: "Feature", properties: {}, geometry: geojson }]
        };
      }
      throw new Error("Unsupported GeoJSON type: " + (geojson.type || typeof geojson));
    }

    async function loadGeoJSON(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to load ${url} (${res.status})`);
      return toFeatureCollection(await res.json());
    }

    function computeBounds(fc) {
      let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;

      const scan = (coords) => {
        if (!coords) return;
        if (typeof coords[0] === "number" && typeof coords[1] === "number") {
          const lng = coords[0], lat = coords[1];
          if (lng < minLng) minLng = lng;
          if (lat < minLat) minLat = lat;
          if (lng > maxLng) maxLng = lng;
          if (lat > maxLat) maxLat = lat;
          return;
        }
        for (const c of coords) scan(c);
      };

      for (const f of (fc.features || [])) {
        if (f && f.geometry) scan(f.geometry.coordinates);
      }

      if (!isFinite(minLng) || !isFinite(minLat) || !isFinite(maxLng) || !isFinite(maxLat)) return null;
      return [[minLng, minLat], [maxLng, maxLat]];
    }

    function mergeBounds(a, b) {
      if (!a) return b;
      if (!b) return a;
      return [
        [Math.min(a[0][0], b[0][0]), Math.min(a[0][1], b[0][1])],
        [Math.max(a[1][0], b[1][0]), Math.max(a[1][1], b[1][1])]
      ];
    }

    // Read a property with case-insensitive fallback
    function getPropInsensitive(props, key) {
      if (!props) return "";
      if (props[key] !== undefined && props[key] !== null && String(props[key]).trim() !== "") return String(props[key]);

      const want = String(key).toLowerCase();
      for (const k of Object.keys(props)) {
        if (k.toLowerCase() === want) {
          const v = props[k];
          if (v !== undefined && v !== null && String(v).trim() !== "") return String(v);
        }
      }
      return "";
    }

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, (m) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#039;"
      }[m]));
    }

    function addVectorLayers() {
      // Annex: 50% transparent fill + outline
      map.addLayer({
        id: LYR_ANNEX_FILL,
        type: "fill",
        source: SRC_ANNEX,
        paint: {
          "fill-color": "rgb(0, 140, 255)",
          "fill-opacity": 0.50
        }
      });

      map.addLayer({
        id: LYR_ANNEX_OUTLINE,
        type: "line",
        source: SRC_ANNEX,
        paint: {
          "line-color": "rgb(0, 90, 180)",
          "line-width": ["interpolate", ["linear"], ["zoom"], 8, 1.2, 12, 2.8, 16, 4.6]
        }
      });

      // Boundaries: red outline only
      map.addLayer({
        id: LYR_BOUND_LINE,
        type: "line",
        source: SRC_BOUND,
        paint: {
          "line-color": "red",
          "line-width": ["interpolate", ["linear"], ["zoom"], 8, 2.2, 12, 4.2, 16, 6.2]
        }
      });
    }

    function setAnnexVisibility(visible) {
      const v = visible ? "visible" : "none";
      [LYR_ANNEX_FILL, LYR_ANNEX_OUTLINE].forEach((id) => {
        if (map.getLayer(id)) map.setLayoutProperty(id, "visibility", v);
      });
    }

    function setAnnexInteractivity(visible) {
      // When annex is hidden, stop pointer cursor over it (handlers remain but layer won't fire).
      // This is mostly visual polish; clicks won't trigger if layer isn't visible.
      if (!visible) {
        // close popup if it was open on annex
        // (we can't easily tell which layer opened it, so just leave it; optional)
      }
    }

    // ====== INIT ======
    map.on("load", async () => {
      try {
        const [annexFC, boundsFC] = await Promise.all([
          loadGeoJSON(ANNEX_URL),
          loadGeoJSON(BOUNDARIES_URL)
        ]);

        // generateId helps with feature querying/interaction consistency
        map.addSource(SRC_ANNEX, { type: "geojson", data: annexFC, generateId: true });
        map.addSource(SRC_BOUND, { type: "geojson", data: boundsFC, generateId: true });

        addVectorLayers();

        // Fit to both datasets
        const merged = mergeBounds(computeBounds(annexFC), computeBounds(boundsFC));
        if (merged) map.fitBounds(merged, { padding: 40, duration: 0 });

        // --- POPUPS ---
        const popup = new maplibregl.Popup({
          closeButton: true,
          closeOnClick: true
        });

        // Click annex fill => show Des
        map.on("click", LYR_ANNEX_FILL, (e) => {
          const f = e.features && e.features[0];
          if (!f) return;

          const des = getPropInsensitive(f.properties, "Des");
          const html = `
            <div class="popup-title">Annex</div>
            <div class="popup-field"><strong>Des:</strong> ${
              des ? escapeHtml(des) : '<span class="popup-muted">(blank)</span>'
            }</div>
          `;

          popup.setLngLat(e.lngLat).setHTML(html).addTo(map);
        });

        // Click boundaries line => show name
        map.on("click", LYR_BOUND_LINE, (e) => {
          const f = e.features && e.features[0];
          if (!f) return;

          const name = getPropInsensitive(f.properties, "name");
          const html = `
            <div class="popup-title">City Boundary</div>
            <div class="popup-field"><strong>name:</strong> ${
              name ? escapeHtml(name) : '<span class="popup-muted">(blank)</span>'
            }</div>
          `;

          popup.setLngLat(e.lngLat).setHTML(html).addTo(map);
        });

        // Pointer cursor feedback (selectable)
        map.on("mouseenter", LYR_ANNEX_FILL, () => map.getCanvas().style.cursor = "pointer");
        map.on("mouseleave", LYR_ANNEX_FILL, () => map.getCanvas().style.cursor = "");
        map.on("mouseenter", LYR_BOUND_LINE, () => map.getCanvas().style.cursor = "pointer");
        map.on("mouseleave", LYR_BOUND_LINE, () => map.getCanvas().style.cursor = "");

        // Toggle annex visibility
        const toggle = document.getElementById("toggleAnnex");
        toggle.addEventListener("change", () => {
          setAnnexVisibility(toggle.checked);
          setAnnexInteractivity(toggle.checked);
        });

      } catch (err) {
        console.error(err);
        alert(
          "Map data failed to load.\n\n" +
          "Confirm these files exist in the repo root and names match exactly:\n" +
          " - new annex.geojson\n" +
          " - new city boundaries.geojson\n\n" +
          "Error: " + err.message
        );
      }
    });
  </script>
</body>
</html>
