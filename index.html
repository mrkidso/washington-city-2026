<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Washington City 2026 – Annexation & New City Boundaries</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- MapLibre GL -->
  <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

  <!-- Turf.js (for pointOnFeature) -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    .controls {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 10;
      background: rgba(255,255,255,0.92);
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.15);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-size: 14px;
      line-height: 1.2;
      max-width: 310px;
      user-select: none;
    }

    .controls .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin: 6px 0;
    }

    .controls .title {
      font-weight: 700;
      margin-bottom: 6px;
      font-size: 14px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #f2f2f2;
      cursor: pointer;
    }

    input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .legend {
      margin-top: 8px;
      border-top: 1px solid rgba(0,0,0,0.08);
      padding-top: 8px;
      color: #333;
    }

    .swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      display: inline-block;
      vertical-align: middle;
      margin-right: 8px;
      border: 1px solid rgba(0,0,0,0.2);
    }

    .muted { color: #666; font-size: 12px; margin-top: 6px; }

    /* ========= HTML label markers ========= */
    :root {
      --labelSize: 14px; /* updated dynamically on zoom */
    }

    .map-label {
      position: relative;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      pointer-events: none; /* not clickable/selectable */
      user-select: none;

      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-weight: 800;
      font-size: var(--labelSize);

      text-shadow:
        0 1px 0 rgba(0,0,0,0.70),
        1px 0 0 rgba(0,0,0,0.70),
        0 -1px 0 rgba(0,0,0,0.70),
        -1px 0 0 rgba(0,0,0,0.70),
        0 2px 6px rgba(0,0,0,0.55);
      line-height: 1.1;
    }

    .label-annex { color: #ffffff; }
    .label-boundary { color: rgb(255, 90, 90); }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="controls">
    <div class="title">Layers</div>

    <div class="row">
      <label class="pill" for="toggleAnnex" title="Toggle the annex polygon on/off">
        <input id="toggleAnnex" type="checkbox" checked />
        <span>Show <strong>new annex.geojson</strong></span>
      </label>
    </div>

    <div class="legend">
      <div class="row" style="justify-content:flex-start;">
        <span class="swatch" style="background: rgba(0, 140, 255, 0.50);"></span>
        <span>Annex (50% transparent fill)</span>
      </div>
      <div class="row" style="justify-content:flex-start;">
        <span class="swatch" style="background: transparent; border: 2px solid red;"></span>
        <span>New City Boundaries (red outline)</span>
      </div>
      <div class="muted">
        Labels are placed using <code>pointOnFeature</code> (inside/on polygons).<br/>
        Annex label field: <code>Des</code> • Boundary label field: <code>name</code><br/>
        Zoom changes label text size.
      </div>
    </div>
  </div>

  <script>
    // ====== FILES (must match your repo filenames exactly) ======
    const ANNEX_URL = "./new annex.geojson";
    const BOUNDARIES_URL = "./new city boundaries.geojson";

    // ====== IDs ======
    const SRC_ANNEX = "src-annex";
    const SRC_BOUND = "src-boundaries";

    const LYR_ANNEX_FILL = "annex-fill";
    const LYR_ANNEX_OUTLINE = "annex-outline";
    const LYR_BOUND_LINE = "boundaries-line";

    // ====== BASEMAP (Satellite + state/city reference) ======
    const style = {
      version: 8,
      sources: {
        "esri-imagery": {
          type: "raster",
          tiles: [
            "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
          ],
          tileSize: 256,
          attribution:
            'Tiles &copy; Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
        },
        "esri-reference": {
          type: "raster",
          tiles: [
            "https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}"
          ],
          tileSize: 256
        }
      },
      layers: [
        { id: "imagery", type: "raster", source: "esri-imagery" },
        { id: "reference", type: "raster", source: "esri-reference" }
      ]
    };

    const map = new maplibregl.Map({
      container: "map",
      style,
      center: [-113.51, 37.13],
      zoom: 11,
      hash: true
    });

    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), "top-right");

    // ====== HTML label markers ======
    const annexLabelMarkers = [];
    const boundaryLabelMarkers = [];

    // ====== HELPERS ======
    function toFeatureCollection(geojson) {
      if (!geojson) throw new Error("Empty GeoJSON");
      if (geojson.type === "FeatureCollection") return geojson;
      if (geojson.type === "Feature") return { type: "FeatureCollection", features: [geojson] };
      if (geojson.type && geojson.coordinates) {
        return {
          type: "FeatureCollection",
          features: [{ type: "Feature", properties: {}, geometry: geojson }]
        };
      }
      throw new Error("Unsupported GeoJSON type: " + (geojson.type || typeof geojson));
    }

    async function loadGeoJSON(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to load ${url} (${res.status})`);
      return toFeatureCollection(await res.json());
    }

    function computeBounds(fc) {
      let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;

      const scan = (coords) => {
        if (!coords) return;
        if (typeof coords[0] === "number" && typeof coords[1] === "number") {
          const lng = coords[0], lat = coords[1];
          if (lng < minLng) minLng = lng;
          if (lat < minLat) minLat = lat;
          if (lng > maxLng) maxLng = lng;
          if (lat > maxLat) maxLat = lat;
          return;
        }
        for (const c of coords) scan(c);
      };

      for (const f of (fc.features || [])) {
        if (f && f.geometry) scan(f.geometry.coordinates);
      }

      if (!isFinite(minLng) || !isFinite(minLat) || !isFinite(maxLng) || !isFinite(maxLat)) return null;
      return [[minLng, minLat], [maxLng, maxLat]];
    }

    function mergeBounds(a, b) {
      if (!a) return b;
      if (!b) return a;
      return [
        [Math.min(a[0][0], b[0][0]), Math.min(a[0][1], b[0][1])],
        [Math.max(a[1][0], b[1][0]), Math.max(a[1][1], b[1][1])]
      ];
    }

    function getPropInsensitive(props, keysPreferred) {
      if (!props) return "";
      // direct checks
      for (const k of keysPreferred) {
        const v = props[k];
        if (v !== undefined && v !== null && String(v).trim() !== "") return String(v);
      }
      // case-insensitive fallback
      const lower = {};
      for (const k of Object.keys(props)) lower[k.toLowerCase()] = k;
      for (const k of keysPreferred) {
        const hit = lower[String(k).toLowerCase()];
        if (hit) {
          const v = props[hit];
          if (v !== undefined && v !== null && String(v).trim() !== "") return String(v);
        }
      }
      return "";
    }

    function clearLabels(arr) {
      while (arr.length) {
        const m = arr.pop();
        try { m.remove(); } catch (_) {}
      }
    }

    function addVectorLayers() {
      // Annex: 50% transparent fill + outline
      map.addLayer({
        id: LYR_ANNEX_FILL,
        type: "fill",
        source: SRC_ANNEX,
        paint: {
          "fill-color": "rgb(0, 140, 255)",
          "fill-opacity": 0.50
        }
      });

      map.addLayer({
        id: LYR_ANNEX_OUTLINE,
        type: "line",
        source: SRC_ANNEX,
        paint: {
          "line-color": "rgb(0, 90, 180)",
          "line-width": ["interpolate", ["linear"], ["zoom"], 8, 1.2, 12, 2.8, 16, 4.6]
        }
      });

      // Boundaries: red outline only
      map.addLayer({
        id: LYR_BOUND_LINE,
        type: "line",
        source: SRC_BOUND,
        paint: {
          "line-color": "red",
          "line-width": ["interpolate", ["linear"], ["zoom"], 8, 2.2, 12, 4.2, 16, 6.2]
        }
      });
    }

    function setAnnexVisibility(visible) {
      const v = visible ? "visible" : "none";
      [LYR_ANNEX_FILL, LYR_ANNEX_OUTLINE].forEach((id) => {
        if (map.getLayer(id)) map.setLayoutProperty(id, "visibility", v);
      });

      // toggle annex HTML labels too
      annexLabelMarkers.forEach(m => {
        m.getElement().style.display = visible ? "" : "none";
      });
    }

    // ====== TRUE label scaling via CSS variable ======
    function labelPxForZoom(z) {
      // Tune these however you want:
      // z=10 -> ~12px, z=13 -> ~16px, z=16 -> ~20px
      const px = 12 + (z - 10) * 1.33;
      return Math.max(10, Math.min(26, px));
    }

    let rafPending = false;
    function updateLabelSize() {
      if (rafPending) return;
      rafPending = true;
      requestAnimationFrame(() => {
        rafPending = false;
        const px = labelPxForZoom(map.getZoom());
        document.documentElement.style.setProperty("--labelSize", px + "px");
      });
    }

    function buildLabels(fc, which) {
      const isAnnex = which === "annex";
      const markers = isAnnex ? annexLabelMarkers : boundaryLabelMarkers;
      const cls = isAnnex ? "label-annex" : "label-boundary";

      clearLabels(markers);

      for (const f of (fc.features || [])) {
        if (!f || !f.geometry) continue;

        const text = isAnnex
          ? getPropInsensitive(f.properties, ["Des", "DES", "des"])
          : getPropInsensitive(f.properties, ["name", "Name", "NAME"]);

        const labelText = (text || "").trim();
        if (!labelText) continue;

        // Robust label point:
// 1) Flatten MultiPolygons into individual polygons
// 2) If self-intersecting, unkink into valid polygons
// 3) Choose the largest polygon piece
// 4) Place a point on that piece
let pt;
try {
  // Flatten to individual polygon features
  const flattened = turf.flatten(f);

  let bestPoly = null;
  let bestArea = -Infinity;

  for (const piece of flattened.features) {
    // If piece is self-intersecting, unkink it into valid polygons
    const unkinked = turf.unkinkPolygon(piece);

    for (const p of unkinked.features) {
      const a = turf.area(p);
      if (a > bestArea) {
        bestArea = a;
        bestPoly = p;
      }
    }
  }

  if (!bestPoly) continue;

  // point guaranteed to be on/inside the chosen polygon piece
  pt = turf.pointOnFeature(bestPoly);
} catch (e) {
  continue;
}

        const coords = pt && pt.geometry && pt.geometry.coordinates;
        if (!coords || coords.length < 2) continue;

        const el = document.createElement("div");
        el.className = `map-label ${cls}`;
        el.textContent = labelText;

        const marker = new maplibregl.Marker({ element: el, anchor: "center" })
          .setLngLat([coords[0], coords[1]])
          .addTo(map);

        markers.push(marker);
      }

      // apply current size immediately
      updateLabelSize();
    }

    // ====== INIT ======
    map.on("load", async () => {
      try {
        const [annexFC, boundsFC] = await Promise.all([
          loadGeoJSON(ANNEX_URL),
          loadGeoJSON(BOUNDARIES_URL)
        ]);

        map.addSource(SRC_ANNEX, { type: "geojson", data: annexFC });
        map.addSource(SRC_BOUND, { type: "geojson", data: boundsFC });

        addVectorLayers();

        // Fit to both datasets
        const merged = mergeBounds(computeBounds(annexFC), computeBounds(boundsFC));
        if (merged) map.fitBounds(merged, { padding: 40, duration: 0 });

        // Build labels (HTML markers)
        buildLabels(boundsFC, "boundary");
        buildLabels(annexFC, "annex");

        // Zoom-driven label scaling (real size change)
        updateLabelSize();
        map.on("zoom", updateLabelSize);
        map.on("zoomend", updateLabelSize);

        // No click/select behavior
        map.getCanvas().style.cursor = "";

        // Toggle annex
        const toggle = document.getElementById("toggleAnnex");
        toggle.addEventListener("change", () => setAnnexVisibility(toggle.checked));

      } catch (err) {
        console.error(err);
        alert(
          "Map data failed to load.\n\n" +
          "Confirm these files exist in the repo root and names match exactly:\n" +
          " - new annex.geojson\n" +
          " - new city boundaries.geojson\n\n" +
          "Error: " + err.message
        );
      }
    });
  </script>
</body>
</html>
