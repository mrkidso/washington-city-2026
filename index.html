<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Washington City 2026 â€“ Annexation & New City Boundaries</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- MapLibre GL -->
  <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

  <!-- Turf.js (for centroids) -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100%; width: 100%; }

    .controls {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 10;
      background: rgba(255,255,255,0.92);
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.15);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-size: 14px;
      line-height: 1.2;
      max-width: 280px;
      user-select: none;
    }

    .controls .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin: 6px 0;
    }

    .controls .title {
      font-weight: 700;
      margin-bottom: 6px;
      font-size: 14px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #f2f2f2;
      cursor: pointer;
    }

    input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .legend {
      margin-top: 8px;
      border-top: 1px solid rgba(0,0,0,0.08);
      padding-top: 8px;
      color: #333;
    }

    .swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      display: inline-block;
      vertical-align: middle;
      margin-right: 8px;
      border: 1px solid rgba(0,0,0,0.2);
    }

    .muted { color: #666; font-size: 12px; margin-top: 6px; }

    /* ---- HTML label markers (non-clickable) ---- */
    .map-label {
      position: relative;
      transform: translate(-50%, -50%);
      white-space: nowrap;
      pointer-events: none; /* IMPORTANT: not clickable/selectable */
      user-select: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-weight: 700;
      text-shadow:
        0 1px 0 rgba(0,0,0,0.65),
        1px 0 0 rgba(0,0,0,0.65),
        0 -1px 0 rgba(0,0,0,0.65),
        -1px 0 0 rgba(0,0,0,0.65),
        0 2px 6px rgba(0,0,0,0.5);
      line-height: 1.1;
    }

    .label-annex {
      color: #ffffff;
      font-weight: 800;
    }

    .label-boundary {
      color: rgb(255, 90, 90);
      font-weight: 800;
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="controls">
    <div class="title">Layers</div>

    <div class="row">
      <label class="pill" for="toggleAnnex" title="Toggle the annex polygon on/off">
        <input id="toggleAnnex" type="checkbox" checked />
        <span>Show <strong>new annex.geojson</strong></span>
      </label>
    </div>

    <div class="legend">
      <div class="row" style="justify-content:flex-start;">
        <span class="swatch" style="background: rgba(0, 140, 255, 0.50);"></span>
        <span>Annex (50% transparent fill)</span>
      </div>
      <div class="row" style="justify-content:flex-start;">
        <span class="swatch" style="background: transparent; border: 2px solid red;"></span>
        <span>New City Boundaries (red outline)</span>
      </div>
      <div class="muted">
        Labels (HTML markers): annex uses <code>Des</code>, boundaries uses <code>name</code> (case-insensitive fallbacks).<br/>
        Zoom in/out: label size scales automatically.
      </div>
    </div>
  </div>

  <script>
    // ====== CONFIG ======
    const ANNEX_URL = "./new annex.geojson";
    const BOUNDARIES_URL = "./new city boundaries.geojson";

    const SRC_ANNEX = "src-annex";
    const SRC_BOUND = "src-boundaries";

    const LYR_ANNEX_FILL = "annex-fill";
    const LYR_ANNEX_OUTLINE = "annex-outline";

    const LYR_BOUND_LINE = "boundaries-line";

    // ====== BASEMAP STYLE (Satellite + Reference boundaries/labels) ======
    const style = {
      version: 8,
      sources: {
        "esri-imagery": {
          type: "raster",
          tiles: [
            "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
          ],
          tileSize: 256,
          attribution:
            'Tiles &copy; Esri &mdash; Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
        },
        "esri-reference": {
          type: "raster",
          tiles: [
            "https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}"
          ],
          tileSize: 256
        }
      },
      layers: [
        { id: "imagery", type: "raster", source: "esri-imagery" },
        { id: "reference", type: "raster", source: "esri-reference" }
      ]
    };

    const map = new maplibregl.Map({
      container: "map",
      style,
      center: [-113.51, 37.13],
      zoom: 11,
      hash: true
    });

    map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), "top-right");

    // ---- HTML label storage ----
    const annexLabelMarkers = [];
    const boundaryLabelMarkers = [];

    // ====== HELPERS ======
    function toFeatureCollection(geojson) {
      if (!geojson) throw new Error("Empty GeoJSON");
      if (geojson.type === "FeatureCollection") return geojson;
      if (geojson.type === "Feature") return { type: "FeatureCollection", features: [geojson] };
      if (geojson.type && geojson.coordinates) {
        return { type: "FeatureCollection", features: [{ type: "Feature", properties: {}, geometry: geojson }] };
      }
      throw new Error("Unsupported GeoJSON type: " + (geojson.type || typeof geojson));
    }

    function computeBounds(featureCollection) {
      let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;

      const scanCoords = (coords) => {
        if (!coords) return;
        if (typeof coords[0] === "number" && typeof coords[1] === "number") {
          const lng = coords[0], lat = coords[1];
          if (lng < minLng) minLng = lng;
          if (lat < minLat) minLat = lat;
          if (lng > maxLng) maxLng = lng;
          if (lat > maxLat) maxLat = lat;
          return;
        }
        for (const c of coords) scanCoords(c);
      };

      for (const f of featureCollection.features || []) {
        if (f && f.geometry) scanCoords(f.geometry.coordinates);
      }

      if (!isFinite(minLng) || !isFinite(minLat) || !isFinite(maxLng) || !isFinite(maxLat)) return null;
      return [[minLng, minLat], [maxLng, maxLat]];
    }

    function mergeBounds(a, b) {
      if (!a) return b;
      if (!b) return a;
      return [
        [Math.min(a[0][0], b[0][0]), Math.min(a[0][1], b[0][1])],
        [Math.max(a[1][0], b[1][0]), Math.max(a[1][1], b[1][1])]
      ];
    }

    function getPropInsensitive(props, preferredKeys) {
      if (!props) return "";
      for (const k of preferredKeys) {
        if (props[k] !== undefined && props[k] !== null && String(props[k]).trim() !== "") return String(props[k]);
      }
      // fallback: case-insensitive search
      const lowerMap = {};
      for (const key of Object.keys(props)) lowerMap[key.toLowerCase()] = key;
      for (const k of preferredKeys) {
        const found = lowerMap[String(k).toLowerCase()];
        if (found && props[found] !== undefined && props[found] !== null && String(props[found]).trim() !== "") {
          return String(props[found]);
        }
      }
      return "";
    }

    async function loadGeoJSON(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to load ${url} (${res.status})`);
      const gj = await res.json();
      return toFeatureCollection(gj);
    }

    function addPolygonLayers() {
      // Annex: 50% transparent fill + outline
      map.addLayer({
        id: LYR_ANNEX_FILL,
        type: "fill",
        source: SRC_ANNEX,
        paint: {
          "fill-color": "rgb(0, 140, 255)",
          "fill-opacity": 0.50
        }
      });

      map.addLayer({
        id: LYR_ANNEX_OUTLINE,
        type: "line",
        source: SRC_ANNEX,
        paint: {
          "line-color": "rgb(0, 90, 180)",
          "line-width": ["interpolate", ["linear"], ["zoom"], 8, 1, 12, 2.5, 16, 4]
        }
      });

      // Boundaries: red outline only
      map.addLayer({
        id: LYR_BOUND_LINE,
        type: "line",
        source: SRC_BOUND,
        paint: {
          "line-color": "red",
          "line-width": ["interpolate", ["linear"], ["zoom"], 8, 2, 12, 4, 16, 6],
          "line-opacity": 1.0
        }
      });
    }

    function setAnnexVisibility(visible) {
      const v = visible ? "visible" : "none";
      [LYR_ANNEX_FILL, LYR_ANNEX_OUTLINE].forEach((id) => {
        if (map.getLayer(id)) map.setLayoutProperty(id, "visibility", v);
      });

      // Also toggle annex HTML labels
      annexLabelMarkers.forEach(m => {
        const el = m.getElement();
        el.style.display = visible ? "" : "none";
      });
    }

    function fontSizeForZoom(z) {
      // Smooth scaling (tweak if you want bigger/smaller)
      // At z=10 ~ 12px, z=13 ~ 16px, z=16 ~ 20px
      const size = 12 + (z - 10) * 1.33;
      return Math.max(10, Math.min(22, size));
    }

    function refreshLabelSizes() {
      const z = map.getZoom();
      const px = fontSizeForZoom(z);

      const all = [...annexLabelMarkers, ...boundaryLabelMarkers];
      for (const m of all) {
        const el = m.getElement();
        el.style.fontSize = px + "px";
      }
    }

    function clearLabels(arr) {
      while (arr.length) {
        const m = arr.pop();
        try { m.remove(); } catch (_) {}
      }
    }

    function buildLabelsFromGeoJSON(featureCollection, which) {
      // which: "annex" or "boundary"
      const markers = (which === "annex") ? annexLabelMarkers : boundaryLabelMarkers;
      const labelClass = (which === "annex") ? "label-annex" : "label-boundary";

      // clear old (in case of reload)
      clearLabels(markers);

      for (const f of (featureCollection.features || [])) {
        if (!f || !f.geometry) continue;

        let labelText = "";
        if (which === "annex") {
          labelText = getPropInsensitive(f.properties, ["Des", "DES", "des"]);
        } else {
          labelText = getPropInsensitive(f.properties, ["name", "Name", "NAME"]);
        }

        labelText = (labelText || "").trim();
        if (!labelText) continue;

        let c;
        try {
          c = turf.centroid(f);
        } catch (e) {
          // centroid can fail for invalid geometries; skip quietly
          continue;
        }

        const coords = c && c.geometry && c.geometry.coordinates;
        if (!coords || coords.length < 2) continue;

        const el = document.createElement("div");
        el.className = `map-label ${labelClass}`;
        el.textContent = labelText;
        el.style.pointerEvents = "none";

        const marker = new maplibregl.Marker({ element: el, anchor: "center" })
          .setLngLat([coords[0], coords[1]])
          .addTo(map);

        markers.push(marker);
      }

      refreshLabelSizes();
    }

    // ====== LOAD DATA + BUILD MAP ======
    map.on("load", async () => {
      try {
        const [annexFC, boundsFC] = await Promise.all([
          loadGeoJSON(ANNEX_URL),
          loadGeoJSON(BOUNDARIES_URL)
        ]);

        map.addSource(SRC_ANNEX, { type: "geojson", data: annexFC });
        map.addSource(SRC_BOUND, { type: "geojson", data: boundsFC });

        addPolygonLayers();

        // Fit to combined bounds
        const b1 = computeBounds(annexFC);
        const b2 = computeBounds(boundsFC);
        const merged = mergeBounds(b1, b2);
        if (merged) map.fitBounds(merged, { padding: 40, duration: 0 });

        // Build HTML labels
        buildLabelsFromGeoJSON(boundsFC, "boundary");
        buildLabelsFromGeoJSON(annexFC, "annex");

        // Keep them sized on zoom
        map.on("zoom", refreshLabelSizes);

        // No click/select behavior
        map.getCanvas().style.cursor = "";

        // Toggle annex fill + labels
        const toggle = document.getElementById("toggleAnnex");
        toggle.addEventListener("change", () => {
          setAnnexVisibility(toggle.checked);
        });

      } catch (err) {
        console.error(err);
        alert(
          "Map data failed to load.\n\n" +
          "Check that these files exist in your repo root and names match exactly:\n" +
          " - new annex.geojson\n" +
          " - new city boundaries.geojson\n\n" +
          "Error: " + err.message
        );
      }
    });
  </script>
</body>
</html>
